# LoL戦績ダッシュボード 詳細設計書

**バージョン**: 1.0  
**作成日**: 2026年2月2日  
**前提**: 基本設計書を読んだ上でこの詳細設計書を参照すること

---

## 1. データモデル詳細定義

### 1.1 matches.json スキーマ

**ルートオブジェクト**:

```
{
  last_update: string (ISO 8601形式)
  summoner: SummonerInfo
  matches: Match[]
}
```

**SummonerInfo型**:

```
{
  name: string          // サマナー名
  puuid: string         // Riot固有ID（64文字）
  region: string        // "jp1", "kr", "na1" など
}
```

**Match型**:

```
{
  matchId: string                    // 例: "JP1_123456789"
  gameCreation: number               // Unix timestamp (ms)
  queueId: number                    // ゲームモードID
  gameDuration: number               // 試合時間（秒）
  gameVersion: string                // 例: "14.3.123.4567"
  myData: PlayerData                 // 自分のデータ
  allPlayers: ParticipantData[10]    // 全プレイヤー（10人固定）
}
```

**PlayerData型（自分のデータ）**:

```
{
  championName: string
  kills: number
  deaths: number
  assists: number
  totalDamageDealtToChampions: number
  totalDamageTaken: number
  win: boolean
  items: ItemPurchase[]              // アイテム購入履歴
  runes: RuneSet                     // ルーン情報
}
```

**ParticipantData型（他プレイヤー）**:

```
{
  summonerName: string
  teamId: number                     // 100=青チーム, 200=赤チーム
  championName: string
  kills: number
  deaths: number
  assists: number
  totalDamageDealtToChampions: number
  totalDamageTaken: number
  tier: string | null                // "DIAMOND", "PLATINUM" など
  rank: string | null                // "I", "II", "III", "IV"
  items: number[]                    // アイテムID配列（最終ビルド）
  runes: RuneSet
}
```

**ItemPurchase型**:

```
{
  itemId: number                     // アイテムID
  timestamp: number                  // 購入時刻（秒、試合開始からの経過時間）
}
```

**RuneSet型**:

```
{
  primary: number[4]                 // メインパス（キーストーン含む4つ）
  secondary: number[2]               // サブパス
  stats: number[3]                   // ステータスルーン
}
```

### 1.2 統計データ型定義

**ChampionStats型（計算結果）**:

```
{
  championName: string
  games: number                      // 試合数
  wins: number                       // 勝利数
  losses: number                     // 敗北数
  winRate: number                    // 勝率（0-100）
  totalKills: number
  totalDeaths: number
  totalAssists: number
  avgKDA: number                     // 平均KDA比率
  avgDamageDealt: number             // 平均与ダメージ
  avgDamageTaken: number             // 平均被ダメージ
}
```

**FilterCondition型**:

```
{
  period: string                     // "all" | "patch_14.3" | "this_week" など
  mode: string                       // "all" | "420" | "450" など（queueId）
}
```

### 1.3 データ制約

**バリデーションルール**:

- matchId: 空文字列不可、ユニーク
- gameCreation: 正の整数、2020年以降のタイムスタンプ
- queueId: 正の整数
- kills/deaths/assists: 0以上の整数
- championName: 空文字列不可、Riot公式チャンピオン名
- items配列: 最大7要素（item0-6）
- allPlayers配列: 必ず10要素

**データ整合性**:

- 重複matchIdは排除（ユニーク制約）
- allPlayersは必ず10人（5vs5）
- teamIdは100または200のみ
- 自分のPUUIDはいずれかのプレイヤーに一致

---

## 2. モジュール詳細仕様

### 2.1 fetch_matches モジュール

**責務**: Riot Games APIから試合データを取得し、内部形式に変換してJSONに保存

#### 2.1.1 RiotAPIClient クラス

**目的**: Riot APIへのHTTPリクエストを管理

**初期化パラメータ**:

```
api_key: string          // Riot API Key
region: string           // デフォルト "jp1"
```

**メソッド一覧**:

**get_summoner(summoner_name: string) → dict**

- 機能: サマナー情報取得
- API: `GET /lol/summoner/v4/summoners/by-name/{name}`
- 戻り値: `{id, accountId, puuid, name, summonerLevel, ...}`
- 例外: RiotAPIError（404時）

**get_match_ids(puuid: string, start: int, count: int) → list[string]**

- 機能: 試合IDリスト取得
- API: `GET /lol/match/v5/matches/by-puuid/{puuid}/ids?start={start}&count={count}`
- パラメータ:
    - start: オフセット（0始まり）
    - count: 取得件数（最大100）
- 戻り値: 試合IDの配列（新しい順）
- 例外: RateLimitError（429時）

**get_match_detail(match_id: string) → dict**

- 機能: 試合詳細取得
- API: `GET /lol/match/v5/matches/{matchId}`
- 戻り値: Riot APIレスポンスそのまま
- 例外: RiotAPIError

**get_all_match_ids(puuid: string) → list[string]**

- 機能: 全試合IDを取得（ページネーション処理）
- 処理フロー:
    1. start=0, count=100で取得
    2. 結果が空 or 100件未満なら終了
    3. そうでなければstart+=100で繰り返し
    4. すべてのIDを結合して返す
- 戻り値: 全試合IDリスト（新しい順）

**_request(url: string, params: dict) → dict**

- 機能: HTTP GETリクエストの共通処理
- 処理内容:
    1. ヘッダーに`X-Riot-Token`設定
    2. requests.get()実行
    3. ステータスコード確認
        - 429: Retry-Afterヘッダーを読んで待機、リトライ
        - 5xx: 3回までリトライ
        - 4xx: 例外スロー
    4. レート制限対策でsleep(1.2秒)
    5. JSONレスポンス返却

#### 2.1.2 データ取得関数

**fetch_new_matches(puuid: string, api_key: string, last_update: string|None) → list[dict]**

- 機能: 新規試合データ取得
- パラメータ:
    - last_update: 前回更新日時（ISO 8601）。Noneなら全件取得
- 処理フロー:
    1. RiotAPIClientインスタンス生成
    2. last_updateがNoneの場合:
        - get_all_match_ids()で全試合ID取得
    3. last_updateがある場合:
        - タイムスタンプに変換
        - get_match_ids()でバッチ取得
        - 各バッチの最初の試合日時をチェック
        - last_update以降の試合のみフィルタ
    4. 各試合IDについてget_match_detail()
    5. process_match_data()で内部形式に変換
    6. リスト化して返す
- 戻り値: Match型のリスト

**process_match_data(raw_match: dict, puuid: string) → dict**

- 機能: Riot APIレスポンスを内部形式に変換
- 処理内容:
    1. raw_match["info"]から試合基本情報抽出
    2. participantsから自分のデータ検索（puuid一致）
    3. アイテム情報を抽出（item0-6）
    4. ルーン情報を抽出（perks構造）
    5. 全10人のプレイヤー情報を抽出
    6. Match型に整形して返す
- 戻り値: Match型のdict

#### 2.1.3 メイン処理

**main() → None**

- 機能: データ取得のエントリーポイント
- 処理フロー:
    1. 環境変数からRIOT_API_KEY、SUMMONER_NAME取得
    2. config.json読み込み
    3. get_summoner()でPUUID取得
    4. data/matches.json存在チェック
        - 存在する: 既存データとlast_update読み込み
        - 存在しない: 空配列、last_update=None
    5. fetch_new_matches()で新規データ取得
    6. 既存データとマージ
    7. matchIdで重複排除
    8. gameCreationでソート（降順）
    9. data/matches.jsonに保存
        - last_updateを現在時刻に更新
- 環境変数:
    - RIOT_API_KEY: 必須
    - SUMMONER_NAME: 必須

---

### 2.2 calculate_stats モジュール

**責務**: 試合データから統計を計算、フィルタリング処理

#### 2.2.1 統計計算関数

**calculate_champion_stats(matches: list[dict], period: string, mode: string) → list[dict]**

- 機能: チャンピオン別統計計算
- パラメータ:
    - matches: Match型のリスト
    - period: 期間フィルター
    - mode: モードフィルター
- 処理フロー:
    1. filter_matches()でフィルタリング
    2. チャンピオン名ごとに集計用dictを作成
    3. 各試合について:
        - games += 1
        - win時: wins += 1
        - kills, deaths, assists加算
        - damageDealt, damageTaken加算
    4. 各チャンピオンについて:
        - winRate = wins / games * 100
        - avgKDA = (kills + assists) / (deaths or 1)
        - avgDamageDealt = damageDealt / games
        - avgDamageTaken = damageTaken / games
    5. gamesでソート（降順）
- 戻り値: ChampionStats型のリスト

**filter_matches(matches: list[dict], period: string, mode: string) → list[dict]**

- 機能: 試合データフィルタリング
- 期間フィルター処理:
    - "all": フィルタなし
    - "patch_X.Y": gameVersionが"X.Y"で始まる試合
    - "this_week": 今週月曜0時以降の試合
    - "last_week": 先週月曜0時〜今週月曜0時
    - "last_30_days": 30日前以降の試合
- モードフィルター処理:
    - "all": フィルタなし
    - その他: queueIdが一致する試合
- 戻り値: フィルタ後のMatch型リスト

**get_recent_matches(matches: list[dict], count: int) → list[dict]**

- 機能: 直近N試合取得
- 処理: gameCreationでソート（降順）して先頭N件
- デフォルト: count=20
- 戻り値: Match型のリスト

#### 2.2.2 メタデータ取得関数

**get_available_patches(matches: list[dict]) → list[string]**

- 機能: 試合データに存在するパッチバージョンリスト
- 処理:
    1. 全試合のgameVersionから"X.Y"部分抽出
    2. セットでユニーク化
    3. ソート（降順）
    4. 先頭5件を返す
- 戻り値: ["14.3", "14.2", "14.1", ...]

**get_available_modes(matches: list[dict]) → list[dict]**

- 機能: 試合データに存在するゲームモードリスト
- 処理:
    1. 全試合のqueueIdを収集
    2. ユニーク化、ソート
    3. 各queueIdをQUEUE_NAMES辞書で変換
        - 未定義の場合: "その他 ({queueId})"
    4. {id: string, name: string}形式で返す
- 戻り値: [{id: "420", name: "ランクソロ/デュオ"}, ...]

#### 2.2.3 定数定義

**QUEUE_NAMES: dict**

```
{
  420: "ランクソロ/デュオ",
  440: "ランクフレックス",
  400: "ノーマル（ドラフト）",
  430: "ノーマル（ブラインド）",
  450: "ARAM",
  1700: "Arena",
  1900: "URF"
}
```

---

### 2.3 generate_html モジュール

**責務**: 統計データから静的HTMLを生成

#### 2.3.1 HTML生成関数

**generate_dashboard() → None**

- 機能: ダッシュボードHTML生成
- 処理フロー:
    1. data/matches.json読み込み
    2. calculate_champion_stats()で全体統計計算
    3. get_recent_matches()で直近試合取得
    4. get_available_patches()でパッチリスト取得
    5. get_available_modes()でモードリスト取得
    6. get_latest_ddragon_version()で最新パッチ番号取得
    7. Jinja2環境設定（templates/ディレクトリ）
    8. index.htmlテンプレート読み込み
    9. テンプレートに以下を渡してレンダリング:
        - summoner: サマナー情報
        - last_update: 最終更新日時
        - champion_stats: チャンピオン統計リスト
        - recent_matches: 直近試合リスト
        - available_patches: パッチリスト
        - available_modes: モードリスト
        - ddragon_version: Data Dragonバージョン
        - all_matches_json: 全試合データ（JSON文字列）
    10. docs/index.htmlに出力

**get_latest_ddragon_version() → string**

- 機能: Data Dragon最新バージョン取得
- 処理:
    1. GET `https://ddragon.leagueoflegends.com/api/versions.json`
    2. JSONパース
    3. 配列の先頭要素を返す
- フォールバック: 失敗時は"14.3.1"を返す
- 戻り値: バージョン文字列（例: "14.3.1"）

#### 2.3.2 テンプレート構造

**base.html**:

- 目的: 共通レイアウト
- ブロック:
    - title: ページタイトル
    - extra_head: 追加ヘッダー
    - content: メインコンテンツ
    - extra_scripts: 追加スクリプト
- スクリプト埋め込み:
    - ALL_MATCHES: 全試合データ（JSON）
    - DDRAGON_VERSION: パッチバージョン

**index.html**:

- 継承: base.html
- セクション:
    - header: サマナー名、最終更新
    - filters: 期間・モードフィルター
    - champion-stats: チャンピオン統計テーブル
    - match-history: 試合履歴リスト
    - match-detail-modal: モーダル（空）

**components/champion_table.html**:

- 目的: チャンピオン統計テーブル
- データソース: champion_stats
- 表示項目:
    - チャンピオン（画像+名前）
    - 試合数
    - 勝率（色分け+W-L）
    - KDA
    - 平均与ダメ（3桁区切り）
    - 平均被ダメ（3桁区切り）
- ソート機能: thにdata-sort属性

**components/match_history.html**:

- 目的: 試合履歴カード
- データソース: recent_matches
- 各カードの表示:
    - 勝敗バッジ
    - チャンピオン画像
    - KDA + KDA比率
    - ゲームモード名
    - 試合時間（分秒）
- クリックイベント: onclick="showMatchDetail('{matchId}')"

**components/match_detail_modal.html**:

- 目的: モーダルの枠組み
- 内容: JavaScriptで動的生成（初期は空）

---

### 2.4 utils モジュール

**責務**: 共通処理、定数定義

#### 2.4.1 API関連定数

**BASE_URLS: dict**

```
{
  "jp1": "https://jp1.api.riotgames.com",
  "kr": "https://kr.api.riotgames.com",
  "asia": "https://asia.api.riotgames.com",  # Match API用
  ...
}
```

**ENDPOINTS: dict**

```
{
  "summoner_by_name": "/lol/summoner/v4/summoners/by-name/{summonerName}",
  "match_ids": "/lol/match/v5/matches/by-puuid/{puuid}/ids",
  "match_detail": "/lol/match/v5/matches/{matchId}"
}
```

#### 2.4.2 エラークラス

**RiotAPIError(Exception)**

- 基底エラークラス

**RateLimitError(RiotAPIError)**

- 429エラー専用

**DataNotFoundError(RiotAPIError)**

- 404エラー専用

#### 2.4.3 ユーティリティ関数

**format_duration(seconds: int) → string**

- 機能: 秒を"MM分SS秒"形式に変換
- 例: 1830 → "30分30秒"

**format_timestamp(timestamp_ms: int) → string**

- 機能: Unix timestamp (ms)を日本語日時文字列に変換
- 例: 1706870400000 → "2024-02-02 14:00"

**get_queue_name(queue_id: int) → string**

- 機能: queueIdからゲームモード名取得
- QUEUE_NAMES辞書を参照
- 未定義の場合: "その他 ({queue_id})"

---

## 3. フロントエンド詳細仕様

### 3.1 HTML構造

**ページ全体のDOM構造**:

```
<body>
  <div class="container">
    <header class="dashboard-header">
      <h1>{サマナー名}</h1>
      <p class="last-update">最終更新: {日時}</p>
    </header>
    
    <section class="filters">
      <div class="filter-group">
        <label for="period-filter">期間:</label>
        <select id="period-filter">...</select>
      </div>
      <div class="filter-group">
        <label for="mode-filter">モード:</label>
        <select id="mode-filter">...</select>
      </div>
    </section>
    
    <section class="champion-stats">
      <h2>チャンピオン統計</h2>
      <table class="champion-table" id="champion-table">
        <thead>...</thead>
        <tbody id="champion-table-body">...</tbody>
      </table>
    </section>
    
    <section class="match-history">
      <h2>試合履歴</h2>
      <div class="match-list" id="match-list">...</div>
    </section>
    
    <div id="match-detail-modal" class="modal">
      <div class="modal-content">
        <span class="close" onclick="closeMatchDetail()">&times;</span>
        <div id="match-detail-content"></div>
      </div>
    </div>
  </div>
  
  <script>
    const ALL_MATCHES = {全試合データJSON};
    const DDRAGON_VERSION = "{パッチバージョン}";
  </script>
  <script src="js/dashboard.js"></script>
</body>
```

**データ属性**:

- .match-card: `data-match-id="{matchId}"`
- th.sortable: `data-sort="{カラム名}"`

### 3.2 CSS設計

**CSS変数定義** (`:root`):

```
--bg-primary, --bg-secondary, --bg-tertiary
--text-primary, --text-secondary, --text-dim
--accent-blue, --accent-red, --accent-gold, --accent-green
--border-dark, --border-light
--text-xs ~ --text-2xl
--weight-normal, --weight-medium, --weight-bold
```

**主要クラス設計**:

**レイアウト**:

- `.container`: max-width 1400px, margin auto, padding 20px
- `.dashboard-header`: text-align center, background --bg-secondary
- `.filters`: display flex, gap 20px

**コンポーネント**:

- `.champion-table`: width 100%, background --bg-secondary
- `.champion-cell`: display flex, align-items center
- `.match-card`: display grid, grid-template-columns, border-left 4px
- `.modal`: position fixed, z-index 1000
- `.modal-content`: background --bg-secondary, max-width 1200px

**状態クラス**:

- `.victory`: border-left-color --accent-blue
- `.defeat`: border-left-color --accent-red
- `.win-rate`: color --accent-blue
- `.loss-rate`: color --accent-red

**ホバー効果**:

```
tr:hover → background --bg-tertiary
.match-card:hover → transform translateX(5px)
select:hover → border-color --border-light
```

### 3.3 JavaScript処理フロー

#### 3.3.1 初期化処理

**DOMContentLoaded イベント**:

1. グローバル変数初期化
    - currentStats = []
    - currentMatches = []
2. イベントリスナー登録
    - #period-filter change → applyFilters()
    - #mode-filter change → applyFilters()
    - .sortable click → sortTable()
3. 初期データ表示
    - currentStats = calculateStats(ALL_MATCHES, 'all', 'all')
    - currentMatches = ALL_MATCHES[0:20]

#### 3.3.2 フィルター処理

**applyFilters() → void**

- 処理フロー:
    1. 選択された期間・モード取得
    2. filterMatches()でフィルタリング
    3. calculateStats()で統計再計算
    4. renderChampionTable()でテーブル再描画
    5. renderMatchList()で試合リスト再描画

**filterMatches(matches, period, mode) → array**

- 処理:
    1. 期間フィルター適用
        - "patch_X.Y": gameVersion前方一致
        - "this_week": 月曜0時以降
        - "last_week": 先週月曜〜今週月曜
        - "last_30_days": 30日前以降
    2. モードフィルター適用
        - queueId一致チェック
    3. フィルタ後配列返却

**calculateStats(matches, period, mode) → array**

- 処理:
    1. チャンピオン名でグループ化
    2. 各グループで集計
        - games, wins, kills, deaths, assists, damage
    3. 統計値計算
        - winRate, avgKDA, avgDamage
    4. gamesでソート（降順）
    5. ChampionStats型の配列返却

#### 3.3.3 テーブル操作

**sortTable(column) → void**

- 処理:
    1. currentSort変数確認
        - 同じカラム: 昇順↔降順トグル
        - 別カラム: 降順に設定
    2. currentStatsをソート
    3. renderChampionTable()で再描画

**renderChampionTable(stats) → void**

- 処理:
    1. tbody要素を取得
    2. stats配列をループ
    3. 各行のHTMLを生成
        - チャンピオン画像URL構築
        - 勝率の色分けクラス
        - 数値フォーマット（3桁区切り）
    4. tbody.innerHTML に設定

**renderMatchList(matches) → void**

- 処理:
    1. match-list要素を取得
    2. matches配列をループ
    3. 各カードのHTMLを生成
        - 勝敗クラス
        - KDA計算
        - 試合時間フォーマット
        - ゲームモード名変換
    4. innerHTML に設定

#### 3.3.4 モーダル操作

**showMatchDetail(matchId) → void**

- 処理:
    1. ALL_MATCHESからmatchId一致を検索
    2. 見つからなければ早期リターン
    3. allPlayersを青・赤チームに分割
        - teamId==100 → blueTeam
        - teamId==200 → redTeam
    4. モーダルコンテンツHTML生成
        - 試合基本情報
        - 青チームテーブル
        - 赤チームテーブル
    5. #match-detail-content に設定
    6. モーダル表示 (display: block)

**renderTeamTable(players) → string**

- 処理:
    1. テーブルHTML開始タグ
    2. players配列をループ
        - チャンピオン画像
        - KDA計算
        - ランク情報整形
        - アイテム画像（ループ）
        - ルーン画像（キーストーンのみ）
    3. テーブルHTML終了タグ
    4. HTML文字列返却

**closeMatchDetail() → void**

- 処理: モーダルを非表示 (display: none)

#### 3.3.5 ヘルパー関数

**getQueueName(queueId) → string**

- QUEUE_NAMES定数から名前取得
- 未定義なら "その他 ({queueId})"

**formatNumber(num) → string**

- 3桁区切りフォーマット（例: 25000 → "25,000"）

**calculateKDA(kills, deaths, assists) → number**

- (kills + assists) / (deaths || 1) を計算
- 小数点2桁で丸める

---

## 4. GitHub Actions詳細仕様

### 4.1 ワークフロー定義

**ファイル**: `.github/workflows/update.yml`

**トリガー**: `workflow_dispatch`（手動実行）

**Job**: `update-dashboard`

**実行環境**: `ubuntu-latest`

### 4.2 Step詳細

**Step 1: Checkout**

- アクション: `actions/checkout@v3`
- 目的: リポジトリをクローン
- オプション: `token: ${{ secrets.GITHUB_TOKEN }}`

**Step 2: Setup Python**

- アクション: `actions/setup-python@v4`
- Python バージョン: 3.11
- 目的: Python環境構築

**Step 3: Cache dependencies**

- アクション: `actions/cache@v3`
- キャッシュパス: `~/.cache/pip`
- キャッシュキー: `requirements.txt`のハッシュ
- 目的: 依存パッケージのインストール高速化

**Step 4: Install dependencies**

- コマンド:
    
    ```
    pip install --upgrade pippip install -r requirements.txt
    ```
    

**Step 5: Fetch match data**

- コマンド: `python src/fetch_matches.py`
- 環境変数:
    - RIOT_API_KEY: `${{ secrets.RIOT_API_KEY }}`
    - SUMMONER_NAME: `${{ secrets.SUMMONER_NAME }}`
- 目的: 試合データ取得・保存

**Step 6: Generate HTML**

- コマンド: `python src/generate_html.py`
- 目的: 静的HTML生成

**Step 7: Commit and push**

- コマンド:
    
    ```
    git config --local user.email "action@github.com"git config --local user.name "GitHub Action"git add data/ docs/git diff --quiet && git diff --staged --quiet || git commit -m "Update dashboard {日時}"git push
    ```
    
- 目的: 変更をコミット・プッシュ
- 注意: 変更なしの場合はスキップ

**Step 8: Deploy to GitHub Pages**

- アクション: `peaceiris/actions-gh-pages@v3`
- オプション:
    - github_token: `${{ secrets.GITHUB_TOKEN }}`
    - publish_dir: `./docs`
    - publish_branch: `gh-pages`
- 目的: GitHub Pagesにデプロイ

### 4.3 必要なSecrets

ユーザーが手動設定する項目:

**RIOT_API_KEY**

- 説明: Riot Developer Portalで取得したPersonal API Key
- 形式: 文字列（約100文字）
- 注意: 24時間で失効する可能性あり

**SUMMONER_NAME**

- 説明: 自分のサマナー名
- 形式: 文字列
- 注意: 空白・特殊文字含む場合あり

**GITHUB_TOKEN**

- 説明: GitHub提供の自動トークン
- 設定不要（自動生成）

---

## 5. エラーハンドリング仕様

### 5.1 Riot API エラー

**429 Rate Limit Exceeded**

- 検出: response.status_code == 429
- 処理:
    1. Retry-Afterヘッダー取得（デフォルト120秒）
    2. ログ出力: "Rate limit hit. Waiting {秒}s..."
    3. sleep(Retry-After秒)
    4. リトライ
- 最大リトライ回数: 制限なし（Retry-After従う）

**404 Not Found**

- 検出: response.status_code == 404
- 処理:
    1. ログ出力: "Data not found: {URL}"
    2. 次の試合へスキップ
- 例外スロー: しない

**5xx Server Error**

- 検出: 500 <= status_code < 600
- 処理:
    1. ログ出力: "Server error: {status_code}"
    2. 5秒待機
    3. リトライ（最大3回）
    4. 3回失敗で例外スロー

**その他エラー**

- 検出: requests.exceptions.RequestException
- 処理: ログ出力してスキップ

### 5.2 データ検証エラー

**JSON保存エラー**

- 検出: json.JSONDecodeError
- 処理:
    1. エラーログ出力
    2. 既存ファイルバックアップ
    3. 例外スロー（処理中断）

**必須フィールド欠損**

- 検出: KeyError
- 処理:
    1. 警告ログ出力
    2. その試合をスキップ
    3. 処理継続

**不正な型**

- 検出: TypeError, ValueError
- 処理:
    1. 警告ログ出力
    2. デフォルト値設定 or スキップ

### 5.3 フロントエンドエラー

**画像読み込み失敗**

- 検出: `<img onerror>`
- 処理: `src="assets/placeholder.png"` に変更

**Data Dragon接続失敗**

- 検出: fetch() のエラー
- 処理:
    1. コンソールエラー出力
    2. フォールバックバージョン使用

**JavaScript実行エラー**

- 検出: try-catch
- 処理:
    1. console.error()出力
    2. ユーザーには何も表示しない（サイレント失敗）

---

## 6. テストケース定義

### 6.1 単体テスト（任意実装）

**fetch_matches モジュール**

テストケース1: 正常系 - サマナー情報取得

- 入力: 有効なサマナー名
- 期待結果: puuid含むdict返却

テストケース2: 異常系 - 存在しないサマナー

- 入力: 存在しないサマナー名
- 期待結果: RiotAPIError例外

テストケース3: 正常系 - 試合ID全件取得

- 入力: 有効なPUUID
- 期待結果: 100件以上のID配列

**calculate_stats モジュール**

テストケース4: 正常系 - チャンピオン統計計算

- 入力: 5試合のモックデータ
- 期待結果: 正しいwinRate, avgKDA

テストケース5: エッジケース - deaths=0の場合

- 入力: deaths=0のデータ
- 期待結果: avgKDA計算でゼロ除算回避

テストケース6: フィルター - パッチ指定

- 入力: 複数パッチの試合データ
- 期待結果: 指定パッチのみ抽出

### 6.2 結合テスト（手動実行）

テストケース7: 初回データ取得

1. 空のリポジトリでActions実行
2. data/matches.json生成確認
3. 試合数が1以上

テストケース8: 差分更新

1. 既存データあり状態でActions実行
2. 新規試合のみ追加確認
3. 重複なし確認

テストケース9: HTML生成

1. データ存在状態でgenerate_html.py実行
2. docs/index.html生成確認
3. ブラウザで表示可能

テストケース10: フィルター動作

1. HTMLをブラウザで開く
2. 期間フィルター変更
3. 統計が再計算される

テストケース11: モーダル表示

1. 試合カードクリック
2. モーダル表示確認
3. 10人のデータ表示確認

### 6.3 受け入れテスト

テストケース12: エンドツーエンド

1. フォークしたリポジトリでセットアップ
2. Secrets設定
3. Actions実行
4. GitHub Pages公開
5. ブラウザアクセス
6. 全機能動作確認

**合格基準**:

- 全試合履歴取得成功
- チャンピオン統計正確
- フィルター動作
- モーダル表示
- 2秒以内に表示

---

## 7. 実装優先順位

### Phase 1: データ取得基盤（最優先）

1. utils.py - 定数・エラークラス
2. fetch_matches.py - RiotAPIClient
3. 単一試合取得のテスト
4. JSON保存確認

### Phase 2: 統計計算（高優先）

1. calculate_stats.py - 基本統計
2. フィルター処理
3. テストデータで検証

### Phase 3: HTML生成（高優先）

1. generate_html.py - 基本構造
2. Jinja2テンプレート作成
3. CSS基本スタイル
4. 静的表示確認

### Phase 4: フロントエンド（中優先）

1. dashboard.js - フィルター処理
2. テーブルソート
3. モーダル表示

### Phase 5: GitHub Actions（中優先）

1. ワークフロー作成
2. ローカルテスト
3. Actions実行確認

### Phase 6: 仕上げ（低優先）

1. エラーハンドリング強化
2. UI微調整
3. README作成

---

## 8. 実装時の注意事項

### 8.1 コーディング規約

**Python**:

- PEP 8準拠
- 関数にdocstring必須
- 型ヒント推奨（必須ではない）
- 変数名: snake_case
- クラス名: PascalCase

**JavaScript**:

- camelCase変数名
- const優先、letは最小限
- アロー関数推奨
- コメント: 処理の意図を説明

**CSS**:

- BEM命名（緩く適用）
- ネスト深さ3階層まで
- !important禁止

### 8.2 パフォーマンス考慮

**避けるべきパターン**:

- ❌ N+1クエリ（APIリクエスト）
- ❌ 巨大なループ内でのDOM操作
- ❌ innerHTML の繰り返し設定

**推奨パターン**:

- ✅ バッチ処理（100件ずつ）
- ✅ DocumentFragment使用
- ✅ デバウンス（検討中）

### 8.3 セキュリティ考慮

**絶対に避けること**:

- ❌ API Keyをコードに埋め込む
- ❌ eval()使用
- ❌ innerHTML に未検証データ挿入

**必須対策**:

- ✅ Jinja2 autoescapeデフォルト有効
- ✅ GitHub Secretsで機密情報管理
- ✅ HTTPS通信（Data Dragon含む）

---
